<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rescue Team Payout Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a professional internal tool look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        .card { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .input-style:focus { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); }
        .result-box { border-left: 6px solid #3b82f6; }
        .rec-box { background-color: #f0fdf4; border: 1px solid #dcfce7; }
        /* Style for mobile responsiveness */
        @media (max-width: 640px) {
            .input-grid { grid-template-columns: 1fr; }
        }
        .table-header { background-color: #f3f4f6; }
        .payout-month { background-color: #a7f3d0; font-weight: 600; border-left: 3px solid #10b981; }
        .schedule-container { display: flex; gap: 24px; flex-direction: column; }
        @media (min-width: 1024px) {
            .schedule-container { flex-direction: row; }
        }
        .table-wrapper { min-width: 50%; }
        .recommendation-tables {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        @media (max-width: 1024px) {
            .recommendation-tables {
                flex-direction: column;
            }
        }
        .rec-metric-grid {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
        }
        /* 6. Tooltip Button Style */
        .calc-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            margin-left: 6px;
            border-radius: 9999px; /* full circle */
            background-color: #d1d5db; /* gray-300 */
            color: #1f2937; /* gray-800 */
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.15s;
        }
        .calc-button:hover {
            background-color: #9ca3af; /* gray-400 */
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 90%;
            width: 500px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div id="app" class="w-full max-w-6xl">
        <header class="text-center mb-8">
             <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800">Rescue Team Payout Calculator</h1>
            <p class="text-gray-500 mt-2">Calculate final Customer payouts and generate strategic internal recommendations.</p>
        </header>

        <div class="card bg-white p-6 md:p-8 rounded-xl">
             <h2 class="text-xl font-semibold text-gray-700 mb-6 border-b pb-2">Customer Parameters</h2>
            
            <form id="calculator-form" class="space-y-6">
                <div class="grid input-grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    
                     <div>
                        <label for="circle-type" class="block text-sm font-medium text-gray-700 mb-1">Circle Type</label>
                        <select id="circle-type" name="circle-type" class="input-style w-full border border-gray-300 p-2 rounded-lg focus:outline-none bg-white">
                            <option value="Normal" selected>Normal</option>
                            <option value="Smart Saving">Smart Saving</option>
                        </select>
                    </div>

                    <div id="payout-input-container" class="col-span-1 md:col-span-2 lg:col-span-1">
                         <label for="payout-amount-normal" class="block text-sm font-medium text-gray-700 mb-1">Requested Payout (EGP)</label>
                        <input type="number" id="payout-amount-normal" name="payout-amount-normal" min="3000" max="1200000" required value="51000"
                               class="input-style w-full border border-gray-300 p-2 rounded-lg focus:outline-none"
                               placeholder="e.g. 51000">
                        <select id="payout-amount-smart" name="payout-amount-smart" class="input-style w-full border border-gray-300 p-2 rounded-lg focus:outline-none bg-white hidden">
                            </select>
                         <p id="payout-helper-text" class="text-xs text-gray-400 mt-1">Multiples of 3,000 EGP (e.g., 3000, 6000, 9000...).</p>
                    </div>

                    <div>
                        <label for="duration" class="block text-sm font-medium text-gray-700 mb-1">Duration (Months)</label>
                        <select id="duration" name="duration" class="input-style w-full border border-gray-300 p-2 rounded-lg focus:outline-none bg-white">
                            </select>
                    </div>

                    <div>
                        <label for="slot-position" class="block text-sm font-medium text-gray-700 mb-1">Slot/Position</label>
                        <select id="slot-position" name="slot-position" class="input-style w-full border border-gray-300 p-2 rounded-lg focus:outline-none bg-white">
                            </select>
                    </div>

                </div>

                <div class="flex justify-end pt-4">
                    <button type="submit" id="calculate-button" 
                            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-150 shadow-md">
                        Calculate Payout
                    </button>
                </div>
            </form>

            <div id="error-message" class="hidden mt-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg text-sm" role="alert"></div>

            <div id="results-section" class="hidden mt-8">
                
                <div class="mb-8">
                    <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">1. Payout Calculation</h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
                        <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
                            <p class="text-sm font-medium text-blue-700 flex items-center">
                                Base Monthly Installment (EGP)
                                <span class="calc-button" onclick="showCalculationSteps('baseInstallment', document.getElementById('result-base-installment').textContent)">?</span>
                            </p>
                            <p id="result-base-installment" class="text-2xl font-bold text-blue-900 mt-1">0.00</p>
                        </div>
                        <div class="p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <p class="text-sm font-medium text-yellow-700 flex items-center">
                                Original Gross Fees/Cashback (EGP) <span class="calc-button" onclick="showCalculationSteps('grossFees', document.getElementById('result-gross-fees').textContent)">?</span>
                            </p>
                            <p id="result-gross-fees" class="text-2xl font-bold text-yellow-800 mt-1">0.00</p>
                        </div>
                        <div class="p-4 bg-green-50 rounded-lg border border-green-200">
                            <p class="text-sm font-medium text-green-700 flex items-center">
                                Total Promo Savings (EGP)
                                <span class="calc-button" onclick="showCalculationSteps('totalSavings', document.getElementById('result-total-savings').textContent)">?</span>
                            </p>
                            <p id="result-total-savings" class="text-2xl font-bold text-green-800 mt-1">0.00</p>
                        </div>
                        <div class="p-4 bg-indigo-50 rounded-lg border border-indigo-200">
                            <p class="text-sm font-medium text-indigo-700">Recommended Promo Code</p>
                            <p id="result-promo-code" class="text-lg font-bold text-indigo-800 mt-1">N/A</p>
                            <p id="result-promo-details" class="text-xs text-indigo-600"></p>
                        </div>
                    </div>

                    <h3 class="font-semibold text-gray-600 mb-3">Installment Schedules:</h3>
                    <div class="schedule-container">
                        
                        <div id="original-schedule-wrapper" class="table-wrapper"> <p class="text-center font-bold text-gray-700 mb-2">Original Schedule (No Promo)</p>
                            <div class="overflow-x-auto rounded-lg border border-gray-200">
                                <table class="min-w-full divide-y divide-gray-200">
                                    <thead class="table-header">
                                        <tr>
                                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-600 uppercase">Mth</th>
                                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-600 uppercase">Installment</th>
                                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-600 uppercase">Net Payout</th>
                                        </tr>
                                    </thead>
                                    <tbody id="installment-table-original-body" class="bg-white divide-y divide-gray-200">
                                        </tbody>
                                </table>
                            </div>
                        </div>

                        <div id="promo-schedule-wrapper" class="table-wrapper hidden">
                            <p class="text-center font-bold text-green-700 mb-2">Schedule with Promo Applied</p>
                            <div class="overflow-x-auto rounded-lg border border-gray-200">
                                <table class="min-w-full divide-y divide-gray-200">
                                    <thead class="table-header">
                                        <tr>
                                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-600 uppercase">Mth</th>
                                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-600 uppercase">New Installment</th>
                                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-600 uppercase">New Payout</th>
                                        </tr>
                                    </thead>
                                    <tbody id="installment-table-promo-body" class="bg-white divide-y divide-gray-200">
                                        </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="rps-section" class="mb-8 pt-8 border-t border-gray-100"> <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">2. RPS Calculation (50 EGP Base)</h2>

                    <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4 bg-gray-50 p-4 rounded-xl border border-gray-200">
                        <div>
                            <p class="text-sm font-medium text-gray-600 flex items-center">
                                Payout Factor (GMV)
                                <span class="calc-button" onclick="showCalculationSteps('payoutFactor', document.getElementById('rps-payout-factor').textContent)">?</span>
                            </p>
                            <p id="rps-payout-factor" class="text-xl font-bold text-gray-800 mt-1">0.00</p>
                        </div>
                        <div>
                            <p class="text-sm font-medium text-gray-600 flex items-center">
                                Position Factor (Slot)
                                <span class="calc-button" onclick="showCalculationSteps('slotFactor', document.getElementById('rps-slot-factor').textContent)">?</span>
                            </p>
                            <p id="rps-slot-factor" class="text-xl font-bold text-gray-800 mt-1">0</p>
                        </div>
                        <div>
                            <p class="text-sm font-medium text-gray-600">Base Value</p>
                            <p id="rps-base" class="text-xl font-bold text-gray-800 mt-1">50 EGP</p>
                        </div>
                        <div class="border-l pl-4 border-gray-300">
                            <p class="text-sm font-medium text-blue-600 flex items-center">
                                Original RPS Score
                                <span class="calc-button" onclick="showCalculationSteps('rpsTotal', document.getElementById('rps-total').textContent)">?</span>
                            </p>
                            <p id="rps-total" class="text-2xl font-bold text-blue-900 mt-1">0.00</p>
                        </div>
                         <div class="border-l pl-4 border-gray-300">
                            <p class="text-sm font-medium text-red-600 flex items-center">
                                RPS with Promo (90%)
                                <span class="calc-button" onclick="showCalculationSteps('rpsPromoTotal', document.getElementById('result-rps-promo-total').textContent)">?</span>
                            </p>
                            <p id="result-rps-promo-total" class="text-2xl font-bold text-red-800 mt-1">0.00</p>
                        </div>
                    </div>
                </div>

                <div id="recommendation-card" class="rec-box p-4 rounded-xl"> <h3 class="font-bold text-xl text-green-700 mb-2">3. Strategic Recommendation</h3>
                    
                    <p id="recommendation-text" class="text-gray-700 mb-4"></p>
                    
                    <div id="recommended-rps-wrapper" class="hidden border-t pt-4 border-green-200">
                        <h4 class="font-bold text-lg text-green-800 mb-3">Recommended Upgrade Metrics:</h4>

                        <div id="rec-summary-card" class="p-3 mb-4 rounded-lg bg-green-100 border border-green-300">
                             <p class="text-lg font-extrabold text-green-900" id="rec-summary-text"></p>
                        </div>
                        <div class="grid rec-metric-grid mb-4">
                            <div class="p-2 bg-green-50 rounded-lg">
                                <p class="text-xs font-medium text-green-700 flex items-center">
                                    New Base Installment (EGP)
                                    <span class="calc-button" onclick="showCalculationSteps('recBaseInstallment', document.getElementById('rec-base-installment').textContent)">?</span>
                                </p>
                                <p id="rec-base-installment" class="font-bold text-green-900 mt-1">0.00</p>
                            </div>
                            <div class="p-2 bg-green-50 rounded-lg">
                                <p class="text-xs font-medium text-green-700 flex items-center">
                                    New Gross Fees (EGP)
                                     <span class="calc-button" onclick="showCalculationSteps('recGrossFees', document.getElementById('rec-gross-fees').textContent)">?</span>
                                </p>
                                <p id="rec-gross-fees" class="font-bold text-green-900 mt-1">0.00</p>
                            </div>
                            <div class="p-2 bg-green-50 rounded-lg">
                                <p class="text-xs font-medium text-green-700">Recommended Promo</p>
                                <p id="rec-promo-code" class="font-bold text-green-900 mt-1">N/A</p>
                            </div>
                            <div class="p-2 bg-green-50 rounded-lg">
                                <p class="text-xs font-medium text-green-700 flex items-center">
                                    Potential Total Savings (EGP)
                                    <span class="calc-button" onclick="showCalculationSteps('recTotalSavings', document.getElementById('rec-total-savings').textContent)">?</span>
                                </p>
                                <p id="rec-total-savings" class="font-bold text-green-900 mt-1">0.00</p>
                            </div>

                            <div class="p-2 bg-green-200 rounded-lg col-span-full md:col-span-1">
                                <p class="text-xs font-medium text-green-900 flex items-center">
                                    Potential New RPS Score (Original)
                                    <span class="calc-button" onclick="showCalculationSteps('recRpsTotal', document.getElementById('recommended-rps-total').textContent)">?</span>
                                </p>
                                <p id="recommended-rps-total" class="text-xl font-bold text-green-900 mt-1">0.00</p>
                            </div>
                                                        <div class="p-2 bg-red-200 rounded-lg">
                                <p class="text-xs font-medium text-red-900 flex items-center">
                                    Potential New RPS (90%)
                                    <span class="calc-button" onclick="showCalculationSteps('recRpsTotalPromo', document.getElementById('rec-rps-promo-total').textContent)">?</span>
                                </p>
                                <p id="rec-rps-promo-total" class="text-xl font-bold text-red-900 mt-1">0.00</p>
                            </div>
                        </div>

                        <div class="recommendation-tables">
                            <div class="table-wrapper">
                                <p class="text-center font-bold text-gray-700 mb-2 text-sm">Recommended Schedule (Original Fees)</p>
                                <div class="overflow-x-auto rounded-lg border border-gray-200">
                                    <table class="min-w-full divide-y divide-gray-200">
                                        <thead class="table-header">
                                            <tr>
                                                <th class="px-3 py-1 text-left text-xs font-medium text-gray-600 uppercase">Mth</th>
                                                <th class="px-3 py-1 text-left text-xs font-medium text-gray-600 uppercase">Install</th>
                                                <th class="px-3 py-1 text-left text-xs font-medium text-gray-600 uppercase">Payout</th>
                                            </tr>
                                        </thead>
                                        <tbody id="rec-table-original-body" class="bg-white divide-y divide-gray-200 text-xs">
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            
                            <div id="rec-promo-comparison-wrapper" class="table-wrapper hidden">
                                <p class="text-center font-bold text-green-700 mb-2 text-sm">Recommended Schedule (Promo Applied)</p>
                                <div class="overflow-x-auto rounded-lg border border-gray-200">
                                    <table class="min-w-full divide-y divide-gray-200">
                                        <thead class="table-header">
                                            <tr>
                                                <th class="px-3 py-1 text-left text-xs font-medium text-gray-600 uppercase">Mth</th>
                                                <th class="px-3 py-1 text-left text-xs font-medium text-gray-600 uppercase">New Install</th>
                                                <th class="px-3 py-1 text-left text-xs font-medium text-gray-600 uppercase">New Payout</th>
                                            </tr>
                                        </thead>
                                        <tbody id="rec-table-new-body" class="bg-white divide-y divide-gray-200 text-xs">
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="calculation-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h4 id="modal-title" class="text-xl font-bold text-gray-800 mb-3 border-b pb-2">Calculation Steps</h4>
            <div id="modal-body" class="text-gray-700 text-sm space-y-3">
                </div>
            <div class="flex justify-end mt-4">
                <button onclick="document.getElementById('calculation-modal').classList.add('hidden')"
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                    Close
                </button>
            </div>
        </div>
    </div>


    <script>
        // Global variables for data and input references
        
        // ** MODIFICATION 1: Declare calculatorData but don't define it. It will be fetched. **
        let calculatorData;
        
        const circleTypeSelect = document.getElementById('circle-type');
        const durationSelect = document.getElementById('duration');
        const slotSelect = document.getElementById('slot-position');
        const payoutAmountInput = document.getElementById('payout-amount-normal'); // Updated ID
        const payoutAmountSelect = document.getElementById('payout-amount-smart'); // Updated ID
        const payoutHelperText = document.getElementById('payout-helper-text'); // Updated ID

        const form = document.getElementById('calculator-form');
        const errorMessageDiv = document.getElementById('error-message'); // Corrected ID
        const resultsSection = document.getElementById('results-section');
        const promoScheduleWrapper = document.getElementById('promo-schedule-wrapper');
        const recommendedRpsWrapper = document.getElementById('recommended-rps-wrapper');
        const recPromoComparisonWrapper = document.getElementById('rec-promo-comparison-wrapper'); 
        const rpsSection = document.getElementById('rps-section');
        const recommendationCard = document.getElementById('recommendation-card');
        const originalScheduleWrapper = document.getElementById('original-schedule-wrapper');

        
        // Helper for currency formatting
        const formatter = new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'EGP',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        });

        // Helper for percentage formatting
        function formatPercent(value) {
             if (value === null || value === undefined || isNaN(value)) return 'N/A';
            return (value * 100).toFixed(2) + '%';
        }

        // --- NEW: Calculation Steps Modal Logic ---
        function showCalculationSteps(metricKey, monthOrValue, tbodyId = null) {
            // Context retrieval logic for modal must be inside the function body
            let currentContext = latestCalculationContext;
            let scheduleData = [];
            
            // Determine if we are in the recommendation section context
            const isRecContext = metricKey.startsWith('rec') || (tbodyId && tbodyId.includes('rec-'));
            let isPromoTable = false; // Flag to identify promo table context

            if (isRecContext && currentContext.rec) {
                currentContext = currentContext.rec; // Switch context to recommendation data
                isPromoTable = tbodyId && tbodyId.includes('new-body'); // Check if it's the promo table in REC section
                scheduleData = isPromoTable ? currentContext.newSchedule : currentContext.newScheduleOriginal;
            } else if (tbodyId) {
                // Main calculation section context
                isPromoTable = tbodyId && (tbodyId.includes('promo-body')); // Check only main promo table ID
                scheduleData = isPromoTable ? currentContext.promoSchedule : currentContext.originalSchedule;
                currentContext = latestCalculationContext; // Ensure we use main context if not rec
            }
            
            // Use correct Payout, Duration, Slot based on context
            const PayoutAmount = isRecContext ? currentContext.newPayout : latestCalculationContext.payout;
            const Duration = isRecContext ? currentContext.newDuration : latestCalculationContext.duration;
            const SlotPosition = isRecContext ? currentContext.newSlot : latestCalculationContext.slot;
            const CircleType = circleTypeSelect.value; // Always get current circle type
            
            const BaseFeePercent = getFeePercent(CircleType, Duration, SlotPosition);
            
            // Use correct Gross Fees based on context
            let GrossFees;
            if (isRecContext) {
                 GrossFees = currentContext.newGrossFees;
            } else {
                 GrossFees = latestCalculationContext.grossFees;
            }

            // Use correct Base Installment based on context
            const BaseInstallment = isRecContext ? currentContext.newBaseInstallment : latestCalculationContext.baseInstallment;
            
            const SlotPromo = getSlotPromocode(Duration, SlotPosition);
            const TotalSavings = currentContext.newTotalSavings !== undefined ? currentContext.newTotalSavings : latestCalculationContext.totalSavings;

            let title = '';
            let steps = [];
            const format = (val) => formatter.format(val);

            // Logic for main metric grid buttons (using latestCalculationContext)
            switch (metricKey) {
                case 'baseInstallment':
                    title = 'Base Monthly Installment Calculation';
                    steps = [
                        `**Requested Payout:** ${format(latestCalculationContext.payout)}`,
                        `**Duration (Months):** ${latestCalculationContext.duration}`,
                        `**Formula:** Payout Amount / Duration`,
                        `**Calculation:** ${format(latestCalculationContext.payout)} / ${latestCalculationContext.duration} = **${format(latestCalculationContext.baseInstallment)}**`,
                    ];
                    break;

                case 'grossFees':
                     title = CircleType === 'Smart Saving' ? 'Cashback Amount Calculation' : 'Original Gross Fees Calculation';
                     const currentFeePercent = getFeePercent(CircleType, latestCalculationContext.duration, latestCalculationContext.slot);
                    if (CircleType === 'Smart Saving') {
                         steps = [
                            `**Requested Payout:** ${format(latestCalculationContext.payout)}`,
                            `**Cashback Percentage:** ${formatPercent(currentFeePercent)} (Based on ${latestCalculationContext.duration} months)`,
                            `**Formula:** Payout Amount \u00D7 Cashback Percentage`,
                            `**Calculation:** ${format(latestCalculationContext.payout)} \u00D7 ${formatPercent(currentFeePercent)} = **${format(Math.abs(latestCalculationContext.grossFees))}**`,
                         ];
                    } else {
                        steps = [
                            `**Requested Payout:** ${format(latestCalculationContext.payout)}`,
                            `**Original Fee Percentage:** ${formatPercent(currentFeePercent)}`,
                            `**Formula:** Payout Amount \u00D7 Original Fee Percentage`,
                            `**Calculation:** ${format(latestCalculationContext.payout)} \u00D7 ${formatPercent(currentFeePercent)} = **${format(Math.abs(latestCalculationContext.grossFees))}** (Fees are positive/negative based on slot)`,
                        ];
                    }
                    break;

                case 'totalSavings':
                    title = 'Total Promo Savings Calculation';
                     if (latestCalculationContext.circleType === 'Smart Saving') {
                         steps = [`Smart Saving Cashback: ${format(latestCalculationContext.totalSavings)}`];
                    } else if (latestCalculationContext.isNegativeFee) {
                         steps = [`Inherent Slot Discount (Negative Fee): ${format(latestCalculationContext.totalSavings)}`];
                    } else if (latestCalculationContext.isZeroFee && latestCalculationContext.promoCode) {
                        const promo = getSlotPromocode(latestCalculationContext.duration, latestCalculationContext.slot);
                        const calculatedInstallmentDiscount = latestCalculationContext.baseInstallment * promo.discount_percent;
                        const actualInstallmentDiscount = Math.min(calculatedInstallmentDiscount, promo.discount_cap);
                        steps = [
                            `**Promo:** ${promo.code}`,
                            `**Discount Type:** Installment Discount (One-Time)`,
                             `**Base Installment:** ${format(latestCalculationContext.baseInstallment)}`,
                            `**Discount Calculation:** ${format(latestCalculationContext.baseInstallment)} \u00D7 ${formatPercent(promo.discount_percent)} = ${format(calculatedInstallmentDiscount)}`,
                            `**Cap Applied:** ${format(actualInstallmentDiscount)} (Capped at ${format(promo.discount_cap)})`,
                            `**Total Savings:** **${format(actualInstallmentDiscount)}** (Applies only to Month 1 Installment)`,
                        ];
                    } else if (latestCalculationContext.isPositiveFee && latestCalculationContext.promoCode) {
                         const promo = getSlotPromocode(latestCalculationContext.duration, latestCalculationContext.slot);
                        const calculatedDiscount = latestCalculationContext.grossFees * promo.discount_percent;
                        const actualDiscount = Math.min(calculatedDiscount, promo.discount_cap);
                         steps = [
                            `**Promo:** ${promo.code}`,
                            `**Discount Type:** Fee Discount`,
                             `**Original Gross Fees:** ${format(latestCalculationContext.grossFees)}`,
                            `**Discount Calculation:** ${format(latestCalculationContext.grossFees)} \u00D7 ${formatPercent(promo.discount_percent)} = ${format(calculatedDiscount)}`,
                            `**Total Savings (Cap Applied):** **${format(actualDiscount)}** (Capped at ${format(promo.discount_cap)})`,
                         ];
                    } else {
                        steps = ['No promo applies, or it\'s a Smart Saving/Negative Fee slot.'];
                    }
                    break;
                
                case 'payoutFactor':
                    title = 'Payout Factor (GMV) Calculation';
                    steps = [`The Payout Factor is **${latestCalculationContext.payoutFactor.toFixed(2)}**, determined by looking up the Requested Payout amount (${format(latestCalculationContext.payout)}) in the GMV Factor table.`];
                    break;
                
                case 'slotFactor':
                    title = 'Position Factor (Slot) Calculation';
                    steps = [`The Position Factor is **${latestCalculationContext.slotFactor}**, determined by looking up the selected Slot (${latestCalculationContext.slot}) in the Slot Factor table.`];
                    break;
                
                case 'rpsTotal':
                    title = 'Original RPS Score Calculation';
                    steps = [
                        `**Payout Factor:** ${latestCalculationContext.payoutFactor.toFixed(2)}`,
                        `**Position Factor:** ${latestCalculationContext.slotFactor}`,
                        `**Base Value:** 50 EGP (Constant)`,
                        `**Formula:** Payout Factor \u00D7 Position Factor \u00D7 Base Value`,
                        `**Calculation:** ${latestCalculationContext.payoutFactor.toFixed(2)} \u00D7 ${latestCalculationContext.slotFactor} \u00D7 50 = **${format(latestCalculationContext.rpsTotal)}**`
                    ];
                    break;

                case 'rpsPromoTotal': // NEW RPS PROMO CALCULATION
                    title = 'Final RPS Score with Promo Discount (90%) Calculation (For Normal Circles Only)';
                    steps = [
                         `**Original RPS Score:** ${format(latestCalculationContext.rpsTotal)}`,
                         `**Promo Discount Applied:** 10%`,
                         `**Formula:** Original RPS \u00D7 0.90`,
                         `**Calculation:** ${format(latestCalculationContext.rpsTotal)} \u00D7 0.90 = **${format(latestCalculationContext.rpsPromoTotal)}**`
                    ];
                    break;

                
                // Logic for table row clicks (Net Installment/Net Payout)
                case 'netInstallment':
                    if (!scheduleData || scheduleData.length === 0) {
                        steps = ['Schedule data not available.']; break;
                    }
                    const monthDataInstall = scheduleData.find(m => m.month === monthOrValue);
                    if (!monthDataInstall) {
                        steps = ['Month data not found.']; break;
                    }
                    
                    // Fee context based on table and promo application
                    let feesForInstallmentCalc = GrossFees; // Default Gross Fees
                    const isPositiveFeeContext = BaseFeePercent > 0; // Fee percent for the specific slot (original or recommended)
                    const isZeroFeeContext = BaseFeePercent === 0;

                     if (isPromoTable && SlotPromo && isPositiveFeeContext) { // If it's a promo table AND positive fee
                        const calculatedDiscount = GrossFees * SlotPromo.discount_percent;
                        const actualDiscount = Math.min(calculatedDiscount, SlotPromo.discount_cap);
                        feesForInstallmentCalc = GrossFees - actualDiscount; // Use Net Fees
                    } else if (isPromoTable && SlotPromo && isZeroFeeContext) { // If it's a promo table AND zero fee
                        feesForInstallmentCalc = 0; // Use 0 fees
                    }
                    
                    const isZeroFeePromoInstall = isPromoTable && isZeroFeeContext && SlotPromo;
                     
                    title = `Installment Breakdown (Month ${monthOrValue})`;
                    
                    if (monthOrValue < SlotPosition) {
                         if (CircleType === 'Smart Saving') {
                             steps = [`**Base Installment:** ${format(BaseInstallment)} (Payout / Duration)`];
                        } else if (feesForInstallmentCalc > 0) { // Positive Fee Normal (with or without discount)
                             const feePerMonthInstall = feesForInstallmentCalc / SlotPosition;
                            steps = [
                                `**Base Installment:** ${format(BaseInstallment)}`,
                                `**Distributed Fee:** + ${format(feePerMonthInstall)} (${(isPromoTable ? 'Net Fees' : 'Gross Fees')} / Slot Position)`,
                                `**Final Installment:** **${format(monthDataInstall.installment)}**`
                            ];
                        } else if (feesForInstallmentCalc < 0) { // Negative Fee Normal
                            const totalDiscount = Math.abs(feesForInstallmentCalc);
                            const discountPerMonth = totalDiscount / 4;
                            const isDiscountMonth = monthOrValue <= 4;
                            steps = [
                                `**Base Installment:** ${format(BaseInstallment)}`,
                                `**Distributed Discount:** - ${isDiscountMonth ? format(discountPerMonth) : '0.00'} (Total Discount / 4)`,
                                `**Final Installment:** **${format(monthDataInstall.installment)}**`
                            ];
                        } else { // Zero Fee Normal
                             if (isZeroFeePromoInstall && SlotPromo) {
                                 const calculatedInstallmentDiscount = BaseInstallment * SlotPromo.discount_percent;
                                 const actualInstallmentDiscount = Math.min(calculatedInstallmentDiscount, SlotPromo.discount_cap);
                                 if (monthOrValue === 1) {
                                     steps = [`**Base Installment:** ${format(BaseInstallment)}`, 
                                              `**Promo Discount (Month 1 Only):** - ${format(actualInstallmentDiscount)}`,
                                              `**Final Installment:** **${format(monthDataInstall.installment)}**`];
                                 } else {
                                     steps = [`**Base Installment:** ${format(BaseInstallment)} (Full amount applied after Month 1)`,
                                              `**Final Installment:** **${format(monthDataInstall.installment)}**`];
                                 }
                             } else {
                                steps = [`**Slot Type:** Zero Fee. The installment equals the Base Monthly Installment. **Final Installment:** ${format(monthDataInstall.installment)}`];
                             }
                        }
                    } else if (monthOrValue === SlotPosition) {
                         steps = [`Payout Month: Installment is **0.00 EGP**.`];
                    } else { // Post-payout month
                        if (CircleType === 'Smart Saving') {
                             steps = [`Post-Payout Month (Smart Saving): Installment equals the **Base Monthly Installment (${format(BaseInstallment)})**. Cashback is applied separately.`];
                        } else {
                            steps = [`Post-Payout Month: Installment equals the **Base Monthly Installment (${format(BaseInstallment)})**. Fees/Discounts handled earlier.`];
                        }
                    }
                    break;

                case 'netPayoutAmount':
                     if (!scheduleData || scheduleData.length === 0) {
                        steps = ['Schedule data not available.']; break;
                    }
                    const monthDataPayout = scheduleData.find(m => m.month === monthOrValue);
                     if (!monthDataPayout || monthDataPayout.month !== SlotPosition) { // Ensure it's the payout month
                        steps = ['Payout calculation only shown for the actual payout month.']; break;
                    }
                    
                    // Use the correct fees for the table (Net Fees if promo table)
                    let feesForPayoutCalc = GrossFees;
                     if (isPromoTable && SlotPromo && BaseFeePercent > 0) { // If promo table AND positive fee
                        const calculatedDiscount = GrossFees * SlotPromo.discount_percent;
                        const actualDiscount = Math.min(calculatedDiscount, SlotPromo.discount_cap);
                        feesForPayoutCalc = GrossFees - actualDiscount; // Use Net Fees
                    } else if (isPromoTable && BaseFeePercent === 0) { // If promo table and zero fee
                        feesForPayoutCalc = 0; // Zero fee promo doesn't affect payout fees
                    }

                    title = `Net Payout Breakdown (Month ${monthOrValue})`;

                    if (CircleType === 'Smart Saving') {
                        const cashbackPercent = getFeePercent(CircleType, Duration, SlotPosition); // For smart saving, fee% is cashback%
                        const cashbackAmount = PayoutAmount * cashbackPercent;
                         steps = [
                            `**Requested Payout:** ${format(PayoutAmount)}`,
                            `**Less Base Installment:** - ${format(BaseInstallment)}`,
                            `**Plus Cashback:** + ${format(cashbackAmount)} (${formatPercent(cashbackPercent)})`,
                            `**Final Net Payout:** **${format(monthDataPayout.netPayout)}**`
                        ];
                    } else if (feesForPayoutCalc > 0) { // Positive Fee Normal
                        const feesRemainingPayout = feesForPayoutCalc / SlotPosition;
                        steps = [
                            `**Requested Payout:** ${format(PayoutAmount)}`,
                            `**Less Base Installment:** - ${format(BaseInstallment)}`,
                            `**Less Remaining Fees:** - ${format(feesRemainingPayout)} (1 installment portion of distributed ${isPromoTable ? 'net' : 'gross'} fees)`,
                            `**Final Net Payout:** **${format(monthDataPayout.netPayout)}**`
                        ];
                    } else { // Zero or Negative Fee Normal
                        steps = [
                            `**Requested Payout:** ${format(PayoutAmount)}`,
                            `**Less Base Installment:** - ${format(BaseInstallment)}`,
                            `**Final Net Payout:** **${format(monthDataPayout.netPayout)}** (Fees/Discount handled through installments)`
                        ];
                    }
                    break;

                // --- Recommendation Metrics ---
                case 'recBaseInstallment':
                    if (!latestCalculationContext.rec) break;
                    title = 'Recommended Base Monthly Installment';
                    steps = [
                        `**Recommended Payout:** ${format(latestCalculationContext.rec.newPayout)}`,
                        `**Duration (Months):** ${Duration}`, // Duration doesn't change
                        `**Formula:** Payout Amount / Duration`,
                        `**Calculation:** ${format(latestCalculationContext.rec.newPayout)} / ${Duration} = **${format(latestCalculationContext.rec.newBaseInstallment)}**`,
                    ];
                    break;
                case 'recGrossFees':
                     if (!latestCalculationContext.rec) break;
                     const recFeePercent = getFeePercent(CircleType, Duration, latestCalculationContext.rec.newSlot);
                    title = 'Recommended Original Gross Fees';
                    steps = [
                        `**Recommended Payout:** ${format(latestCalculationContext.rec.newPayout)}`,
                        `**Original Fee Percentage (at New Slot ${latestCalculationContext.rec.newSlot}):** ${formatPercent(recFeePercent)}`,
                        `**Calculation:** ${format(latestCalculationContext.rec.newPayout)} \u00D7 ${formatPercent(recFeePercent)} = **${format(Math.abs(latestCalculationContext.rec.newGrossFees))}**`,
                    ];
                    break;
                case 'recRpsTotal':
                     if (!latestCalculationContext.rec) break;
                     const newPayoutFactor = getPayoutFactor(latestCalculationContext.rec.newPayout);
                     const newSlotFactor = getSlotFactor(latestCalculationContext.rec.newSlot);
                    title = 'Potential New RPS Score Calculation (100% Original)';
                    const recRpsOriginal = latestCalculationContext.rec.newRps / 0.90;
                    steps = [
                        `**New Payout Factor (GMV):** ${newPayoutFactor.toFixed(2)}`,
                        `**New Position Factor (Slot):** ${newSlotFactor}`,
                        `**Base Value:** 50 EGP (Constant)`,
                        `**Formula:** Payout Factor \u00D7 Position Factor \u00D7 Base Value`,
                        `**Calculation:** ${newPayoutFactor.toFixed(2)} \u00D7 ${newSlotFactor} \u00D7 50 = **${format(recRpsOriginal)}**`
                    ];
                    break;
                case 'recTotalSavings':
                    if (!latestCalculationContext.rec) break;
                    title = 'Potential Total Savings Calculation';
                    steps = [`Savings calculation is based on the recommended promo code and the new Gross Fees. **Total Savings:** ${format(latestCalculationContext.rec.newTotalSavings)}`];
                    break;
                case 'recRpsTotalPromo':
                     if (!latestCalculationContext.rec) break;
                     const originalRecRpsPromo = latestCalculationContext.rec.newRps / 0.90;
                    title = 'Potential New RPS Score with Promo Discount (90%) Calculation';
                    steps = [
                         `**Original Recommended RPS:** ${format(originalRecRpsPromo)}`,
                         `**Promo Discount Applied:** 10%`,
                         `**Formula:** Original RPS \u00D7 0.90`,
                         `**Calculation:** ${format(originalRecRpsPromo)} \u00D7 0.90 = **${format(latestCalculationContext.rec.newRps)}**`
                    ];
                    break;

                default:
                    title = 'Calculation Steps';
                    steps = ['Detailed steps are not available for this metric key.'];
            }

            const modalBody = document.getElementById('modal-body');
            document.getElementById('modal-title').textContent = title;
            modalBody.innerHTML = steps.map(step => `<p>${step.replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>')}</p>`).join(''); // Added Markdown bold support
            document.getElementById('calculation-modal').classList.remove('hidden');
        }
        // --- END: Calculation Steps Modal Logic ---


        /**
         * 1. DATA LOOKUP HELPERS
         */

        // Gets the fee percentage from the matrix
        function getFeePercent(circleType, duration, slot) {
            // ** FIX: Ensure key uses consistent naming convention **
            const key = `${duration}M_${circleType.toUpperCase().replace(/\s/g, '_')}`;
            const feeMatrix = calculatorData.rosca_fees_matrix[key];
             // ** For Smart Saving, return the cashback percent directly **
            if (circleType === 'Smart Saving') {
                switch (duration) {
                    case 6: return 0.05;
                    case 12: return 0.10;
                    case 24: return 0.20;
                    default: return null; // Should not happen with validation
                }
            }
            if (!feeMatrix) return null; // Added check for Normal types
            const entry = feeMatrix.find(item => item.slot === slot);
            return entry ? entry.fee_percent : null;
        }

        // Gets the specific promo for the current selection
        function getSlotPromocode(duration, slot) {
            return calculatorData.slot_promocodes.find(promo => 
                promo.duration === duration && promo.slot === slot
            );
        }

        // Gets the GMV Factor for RPS calculation
        function getPayoutFactor(payoutAmount) {
            const gmvTable = calculatorData.rps_datasets.gmv_factor_table;
            
            // Assuming GMV table is sorted by payout (which it is)
            for (let i = gmvTable.length - 1; i >= 0; i--) {
                if (payoutAmount >= gmvTable[i].payout) {
                    return gmvTable[i].factor;
                }
            }
            // ** FIX: Return 0.0 if below the minimum (15000 EGP) **
            return 0.0;
        }
        
        // Checks if the payout amount is a valid entry in the GMV table (for Normal)
        function isValidNormalPayoutAmount(payoutAmount) {
             // ** NEW LOGIC: Must be a multiple of 3000 EGP **
             if (payoutAmount < 3000 || payoutAmount > 1200000) return false;
             // Check for divisibility by 3000
             return payoutAmount % 3000 === 0;
        }
         // Checks if the payout amount is valid for Smart Saving
        function isValidSmartSavingPayoutAmount(payoutAmount) {
             return calculatorData.smart_saving_payouts.includes(payoutAmount);
        }

        // Gets the Slot Factor for RPS calculation
        function getSlotFactor(slot) {
            const slotTable = calculatorData.rps_datasets.slot_factor_table;
            const entry = slotTable.find(item => item.position === slot);
            return entry ? entry.factor : 1; // Default factor
        }

        /**
         * 2. DYNAMIC UI LOGIC 
         */
         
        // ** NEW Function to handle Circle Type changes **
        function handleCircleTypeChange() {
             const circleType = circleTypeSelect.value;
             const isSmartSaving = circleType === 'Smart Saving';

             // Toggle Payout Input Type
             payoutAmountInput.classList.toggle('hidden', isSmartSaving);
             payoutAmountSelect.classList.toggle('hidden', !isSmartSaving);
             payoutHelperText.textContent = isSmartSaving ? 'Select a valid payout amount.' : 'Multiples of 3,000 EGP (e.g., 3000, 6000...).';

             if (isSmartSaving) {
                 // Populate Smart Saving Payout dropdown
                 payoutAmountSelect.innerHTML = '';
                 calculatorData.smart_saving_payouts.forEach(amount => {
                     const option = document.createElement('option');
                     option.value = amount;
                     option.textContent = formatter.format(amount);
                     payoutAmountSelect.appendChild(option);
                 });
                 // Set a default value if needed
                 if (calculatorData.smart_saving_payouts.length > 0) {
                      payoutAmountSelect.value = calculatorData.smart_saving_payouts[0];
                 }
             } else {
                 // Reset Normal input if needed
                 payoutAmountInput.value = 51000; 
             }

             // --- VISIBILITY FIX STARTS HERE ---
             
             // 1. Hide RPS Section (Section 2) for Smart Saving? 
             // Usually RPS (Gamification Score) is only for Normal slots. 
             // We keep it hidden for Smart Saving to avoid confusion with "0" scores.
             rpsSection.classList.toggle('hidden', isSmartSaving);
             
             // 2. Recommendation Card (Section 3) 
             // We MUST show this for Smart Saving now that we have logic for it.
             recommendationCard.classList.remove('hidden'); 
             
             // --- VISIBILITY FIX ENDS HERE ---
             
             // Update Duration options which will trigger slot update and calculation
             updateDurationOptions(); 
        }

        function updateDurationOptions() {
            const circleType = circleTypeSelect.value;
            let durations = [];

            if (circleType === 'Normal') {
                durations = [6, 10, 12];
            } else if (circleType === 'Smart Saving') {
                durations = [6, 12, 24];
            }

            // Store current selection to restore if possible
            const currentDuration = durationSelect.value;

            durationSelect.innerHTML = '';
            durations.forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                option.textContent = `${d} Months`;
                durationSelect.appendChild(option);
            });
            
            // Restore selection or default to first
            if (durations.includes(parseInt(currentDuration))) {
                durationSelect.value = currentDuration;
            } else if (durations.length > 0) {
                 durationSelect.value = durations[0];
            }
            
            updateSlotOptions(); // This will populate slots
            
            // ** FIX: Ensure calculation only happens after both dropdowns have a value **
            if (durationSelect.value && slotSelect.value) {
                 calculatePayout(null); // Now it's safe to call
            }
        }

        function updateSlotOptions() {
            const circleType = circleTypeSelect.value;
            const duration = parseInt(durationSelect.value);
            
            slotSelect.innerHTML = '';

            if (circleType === 'Normal') {
                // Normal Circle: Slots are 1 to the selected Duration
                const maxSlot = duration;
                for (let i = 1; i <= maxSlot; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `Slot ${i}`;
                    slotSelect.appendChild(option);
                }
                slotSelect.disabled = false;
            } else if (circleType === 'Smart Saving') {
                // Smart Saving: Slot must equal Duration
                if (duration) {
                    const option = document.createElement('option');
                    option.value = duration;
                    option.textContent = `Slot ${duration} (Fixed)`;
                    slotSelect.appendChild(option);
                }
                slotSelect.disabled = true; 
            }
            // ** NEW: Ensure initial slot value is set before calculation **
            if (slotSelect.options.length > 0) {
                 // No need to manually set value, browser default is fine
            }
        }

        /**
         * 3. RENDERING
         */

        // Renders one of the two installment tables (Original or Promo)
        function renderInstallmentTable(tbodyId, schedule, slotPosition) {
            const tbody = document.getElementById(tbodyId);
             if (!tbody) { console.error(`Table body not found: ${tbodyId}`); return; } // Robustness check
            tbody.innerHTML = '';
            
            schedule.forEach(monthData => {
                const isPayoutMonth = (monthData.month === slotPosition);
                
                const row = tbody.insertRow();
                row.className = isPayoutMonth ? 'payout-month' : 'hover:bg-gray-50';

                // Month
                const cell1 = row.insertCell(0);
                cell1.className = "px-3 py-2 whitespace-nowrap text-sm text-gray-700";
                cell1.textContent = monthData.month;
                
                // Installment Amount
                const cell2 = row.insertCell(1);
                cell2.className = "px-3 py-2 whitespace-nowrap text-sm text-gray-700 font-medium";
                // ** FIX: Added '?' button to Installment **
                cell2.innerHTML = `
                    <span class="flex items-center">
                        ${formatter.format(monthData.installment)}
                        <span class="calc-button" 
                              onclick="showCalculationSteps('netInstallment', ${monthData.month}, '${tbodyId}')">?</span>
                    </span>`;
                
                // Net Payout Amount 
                const cell3 = row.insertCell(2);
                cell3.className = "px-3 py-2 whitespace-nowrap text-sm text-gray-700";
                
                if (isPayoutMonth) {
                    // ** FIX: Added '?' button to Net Payout **
                     cell3.innerHTML = `
                        <span class="flex items-center">
                            ${formatter.format(monthData.netPayout)}
                            <span class="calc-button" 
                                  onclick="showCalculationSteps('netPayoutAmount', ${monthData.month}, '${tbodyId}')">?</span>
                        </span>`;
                } else {
                     cell3.textContent = '-';
                }
                
                // Apply styling based on payout month
                if (isPayoutMonth) {
                    cell3.classList.remove('text-gray-700'); 
                    cell3.classList.add('text-green-700', 'font-bold');
                } else {
                    cell3.classList.remove('text-gray-700'); 
                    cell3.classList.add('text-gray-400');
                }
            });
        }

        // Renders the two tables within the recommendation section
        function renderRecommendationDetails(originalSchedule, newSchedule, currentSlot, recommendedSlot, newMetrics, recommendedSlotIsNegativeFee) {
            
            // The position to highlight the payout month in BOTH tables of the recommendation section
            const payoutPositionForRec = recommendedSlot;

            // Re-render original schedule (no promo)
            renderInstallmentTable('rec-table-original-body', originalSchedule, payoutPositionForRec);

            // Render the new recommended schedule
            renderInstallmentTable('rec-table-new-body', newSchedule, payoutPositionForRec);

            // Update new metrics grid
            document.getElementById('rec-base-installment').textContent = formatter.format(newMetrics.newBaseInstallment);
            document.getElementById('rec-gross-fees').textContent = formatter.format(Math.abs(newMetrics.newGrossFees));
            document.getElementById('rec-promo-code').textContent = newMetrics.newPromoCode || 'N/A';
            document.getElementById('rec-total-savings').textContent = formatter.format(newMetrics.newTotalSavings); // NEW SAVINGS METRIC
            
            // Color code new gross fees
            const recGrossFeesEl = document.getElementById('rec-gross-fees');
            recGrossFeesEl.classList.remove('text-green-900', 'text-red-600');
             if (newMetrics.newGrossFees > 0) {
                recGrossFeesEl.classList.add('text-red-600');
            } else {
                recGrossFeesEl.classList.add('text-green-900');
            }
            
            // ** NEW CONSTRAINT: Hide promo comparison wrapper if recommended slot is negative **
            if (recommendedSlotIsNegativeFee || newMetrics.newPromoCode === 'N/A') {
                 recPromoComparisonWrapper.classList.add('hidden');
                 // For negative slots, gross fees is the discount, so we clear the promo metrics but keep the schedule tables.
                 if (recommendedSlotIsNegativeFee) {
                     document.getElementById('rec-promo-code').textContent = 'N/A (Discount Slot)'; 
                     document.getElementById('rec-total-savings').textContent = formatter.format(newMetrics.newTotalSavings);
                 }
            } else {
                 recPromoComparisonWrapper.classList.remove('hidden');
            }

            // ** NEW: Set the summary text **
            const summaryTextEl = document.getElementById('rec-summary-text');
            if (newMetrics.type === 'payout') {
                summaryTextEl.textContent = `Increase Payout: ${formatter.format(newMetrics.originalPayout)} \u2192 ${formatter.format(newMetrics.newPayout)}`;
            } else {
                summaryTextEl.textContent = `Change Slot: Slot ${newMetrics.originalSlot} \u2192 Slot ${newMetrics.newSlot}`;
            }

            recommendedRpsWrapper.classList.remove('hidden');
        }
        
        // Updated function signature to include totalSavings
        function renderPayoutResults(installmentAmount, grossFees, promoCode, promoDetails, payoutFactor, slotFactor, rpsTotal, feeType, rpsRecommendation, totalSavings, rpsPromoTotal) { // Added rpsPromoTotal
            document.getElementById('result-base-installment').textContent = formatter.format(installmentAmount);
            document.getElementById('result-gross-fees').textContent = formatter.format(Math.abs(grossFees)); // Show absolute value
            document.getElementById('result-total-savings').textContent = formatter.format(totalSavings); // NEW SAVINGS METRIC

            // Apply color coding based on sign of fees and type
            const grossFeesEl = document.getElementById('result-gross-fees');
            grossFeesEl.classList.remove('text-red-600', 'text-green-600', 'text-yellow-800');
            if (circleTypeSelect.value === 'Smart Saving') {
                 grossFeesEl.classList.add('text-green-600'); // Cashback is always green
            } else if (grossFees > 0) {
                grossFeesEl.classList.add('text-red-600');
            } else if (grossFees < 0) {
                grossFeesEl.classList.add('text-green-600');
            } else {
                grossFeesEl.classList.add('text-yellow-800');
            }

            // Promocode Display
            document.getElementById('result-promo-code').textContent = promoCode || 'N/A';
            document.getElementById('result-promo-details').textContent = promoDetails || (feeType === 'Negative Fee' ? 'No promo available for discount slots.' : 'No promo applies to this slot.');
            
            // RPS Display (Only show if Normal)
            if (circleTypeSelect.value === 'Normal') {
                document.getElementById('rps-payout-factor').textContent = payoutFactor.toFixed(2);
                document.getElementById('rps-slot-factor').textContent = slotFactor;
                document.getElementById('rps-total').textContent = formatter.format(rpsTotal);
                document.getElementById('result-rps-promo-total').textContent = formatter.format(rpsPromoTotal); // NEW RPS PROMO DISPLAY
            }
            
            // --- Recommendation Section Rendering ---
            
            // 1. Recommendation Text
            let recText;
            if (rpsRecommendation.upgradeFound) {
                // This text is now just the fallback header
                recText = "An RPS upgrade opportunity has been identified for this selection:";
            } else {
                 // 2. Default strategic advice based on fee type if no RPS upgrade is found
                const strategicRec = calculatorData.recommendation_list.find(r => r.trigger_type === feeType);
                recText = strategicRec ? `${strategicRec.text} \n\n(Note: No immediate RPS score upgrade was found for this combination.)` : 'No recommendation available.';
                recommendedRpsWrapper.classList.add('hidden');
            }
            document.getElementById('recommendation-text').textContent = recText;
            document.getElementById('recommended-rps-total').textContent = rpsRecommendation.upgradeFound ? formatter.format(rpsRecommendation.newRps / 0.90) : 'N/A'; // Show original RPS for rec
            document.getElementById('rec-rps-promo-total').textContent = rpsRecommendation.upgradeFound ? formatter.format(rpsRecommendation.newRps) : 'N/A'; // Show new promo RPS
        }

        /**
         * 4. ERROR HANDLING
         */
        function showError(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.classList.remove('hidden');
            resultsSection.classList.add('hidden');
        }

        function hideError() {
            errorMessageDiv.classList.add('hidden');
        }

        /**
         * 5. MAIN CALCULATION FUNCTION
         */
        
        // --- UPDATED RPS RECOMMENDATION LOGIC (Handles Normal 3k multiples & Smart Saving fixed amounts) ---
        function getRpsRecommendation(currentPayout, duration, currentSlot, isPositiveFee, baseFeePercent, baseInstallment, grossFeesEGP, currentRpsTotal) {
            // Recommendation object structure
            const NO_UPGRADE = { upgradeFound: false, text: '', newRps: 0, newSchedule: null };
            
            // Validation check
            if (duration < 6 || currentSlot > duration) return NO_UPGRADE;
            
            const currentGMVFactor = getPayoutFactor(currentPayout);
            const currentSlotFactor = getSlotFactor(currentSlot);
            const RPS_PROMO_MULTIPLIER = 0.90; // 10% discount
            
            // Define strictness for financial advice
            // Normal: Strict 25% cap (don't suggest huge jumps)
            // Smart Saving: Loose cap (200%) because fixed tiers have large gaps (e.g. 30k -> 60k)
            const INCREASE_CAP = circleTypeSelect.value === 'Smart Saving' ? 2.0 : 0.25; 

            // ------------------------------------
            // A. PRIORITY 1: PAYOUT UPGRADE (GMV Factor)
            // ------------------------------------
            
            let targetPayout = null;
            let targetFactor = 0;
            
            if (circleTypeSelect.value === 'Smart Saving') {
                // --- SMART SAVING LOGIC ---
                // Look for the next payout in the specific fixed list that yields a higher Factor
                const allowedPayouts = calculatorData.smart_saving_payouts;
                const currentIdx = allowedPayouts.indexOf(currentPayout);
                
                if (currentIdx !== -1) {
                    for (let i = currentIdx + 1; i < allowedPayouts.length; i++) {
                        const candidatePayout = allowedPayouts[i];
                        const candidateFactor = getPayoutFactor(candidatePayout);
                        
                        if (candidateFactor > currentGMVFactor) {
                            targetPayout = candidatePayout;
                            targetFactor = candidateFactor;
                            break; // Found the next tier up
                        }
                    }
                }
            } else {
                // --- NORMAL LOGIC ---
                // Look at GMV table, find next factor, calculate min payout, round to 3000
                const gmvTable = calculatorData.rps_datasets.gmv_factor_table;
                const distinctFactors = [...new Set(gmvTable.map(item => item.factor))].sort((a, b) => a - b);
                const nextFactorIndex = distinctFactors.findIndex(f => f > currentGMVFactor);

                if (nextFactorIndex !== -1) {
                    targetFactor = distinctFactors[nextFactorIndex];
                    let rawMinPayout = gmvTable.find(item => item.factor === targetFactor)?.payout;
                    
                    if (rawMinPayout) {
                        // Round up to nearest 3000 if not divisible
                        if (rawMinPayout % 3000 !== 0) {
                            targetPayout = Math.ceil(rawMinPayout / 3000) * 3000;
                        } else {
                            targetPayout = rawMinPayout;
                        }
                    }
                }
            }

            // Process the upgrade if a target was found
            if (targetPayout) {
                const increasePercent = (targetPayout - currentPayout) / currentPayout;

                // Apply financial constraint check
                if (increasePercent > 0 && increasePercent <= INCREASE_CAP) {
                    
                    // --- Calculate recommended schedule details ---
                    const newRpsOriginal = (targetFactor * currentSlotFactor * 50); // RPS before promo discount
                    // Smart Saving usually doesn't have promo discounts on RPS, but keeping formula consistent
                    const newRpsTotal = circleTypeSelect.value === 'Normal' ? newRpsOriginal * RPS_PROMO_MULTIPLIER : newRpsOriginal; 
                    
                    const newBaseInstallment = targetPayout / duration;
                    
                    // Recalculate fees (Smart Saving fee % might change based on payout? usually only duration)
                    // Note: Code assumes fee % depends on duration/slot, not payout.
                    const newGrossFees = targetPayout * baseFeePercent; 

                    const newPromo = circleTypeSelect.value === 'Normal' ? getSlotPromocode(duration, currentSlot) : null; 
                    let newNetFees = newGrossFees;
                    let newIsZeroPromo = false;
                    let newTotalSavings = 0;

                    // Promo Logic (Only for Normal)
                    if (newPromo && circleTypeSelect.value === 'Normal') {
                        if (isPositiveFee) {
                            const calculatedDiscount = newGrossFees * newPromo.discount_percent;
                            const actualDiscount = Math.min(calculatedDiscount, newPromo.discount_cap);
                            newNetFees = newGrossFees - actualDiscount;
                            newTotalSavings = actualDiscount;
                        } else if (baseFeePercent === 0) {
                                newNetFees = 0;
                                newIsZeroPromo = true;
                                const calculatedInstallmentDiscount = newBaseInstallment * newPromo.discount_percent;
                                const actualInstallmentDiscount = Math.min(calculatedInstallmentDiscount, newPromo.discount_cap);
                                newTotalSavings = actualInstallmentDiscount; 
                        }
                    } else if (circleTypeSelect.value === 'Smart Saving') {
                        // Smart Saving "Savings" = The Cashback Amount (Gross Fees)
                        newTotalSavings = Math.abs(newGrossFees);
                    } else if (baseFeePercent < 0) { 
                        newTotalSavings = Math.abs(newGrossFees);
                    }
                    
                    const recommendedSchedule = buildSchedule(newBaseInstallment, newNetFees, duration, currentSlot, targetPayout, newIsZeroPromo, circleTypeSelect.value); 
                    const originalScheduleForRec = buildSchedule(newBaseInstallment, newGrossFees, duration, currentSlot, targetPayout, false, circleTypeSelect.value);

                    return {
                        upgradeFound: true,
                        type: 'payout',
                        newRps: newRpsTotal,
                        newSchedule: recommendedSchedule,
                        newScheduleOriginal: originalScheduleForRec,
                        newSlot: currentSlot, 
                        newPayout: targetPayout,
                        newBaseInstallment: newBaseInstallment,
                        newGrossFees: newGrossFees,
                        newPromoCode: newPromo ? newPromo.code : 'N/A',
                        newTotalSavings: newTotalSavings,
                        originalSlot: currentSlot, 
                        originalPayout: currentPayout, 
                        text: `STRATEGIC UPSELL: Recommend increasing the Payout Amount to ${formatter.format(targetPayout)} to achieve the next GMV Factor of ${targetFactor.toFixed(2)}. This is a ${formatPercent(increasePercent)} increase.`,
                    };
                }
            }
            
            // ------------------------------------
            // B. PRIORITY 2: SLOT UPGRADE (Position Factor)
            // ------------------------------------
            
            // Slot upgrades are NOT available for Smart Saving (fixed slots)
            if (circleTypeSelect.value === 'Smart Saving') return NO_UPGRADE;

            // ** CONSTRAINT: If slot is 1, skip slot recommendations **
            if (currentSlot === 1) return NO_UPGRADE;
            
            let checkRange = isPositiveFee ? 1 : 2; 
            let bestSlotRecommendation = NO_UPGRADE;
            const RPS_FACTOR_JUMP = 2;
            let maxFactorJump = 0;

            for (let offset = -checkRange; offset <= checkRange; offset++) {
                if (offset === 0) continue; 
                
                const targetSlot = currentSlot + offset;
                
                if (targetSlot >= 1 && targetSlot <= duration) {
                    const targetFeePercent = getFeePercent('Normal', duration, targetSlot);
                    if (targetFeePercent === null) continue; 
                    
                    const targetSlotFactor = getSlotFactor(targetSlot);

                    if (isPositiveFee && targetFeePercent < 0.00001) {
                         continue; 
                    }

                    const factorJump = targetSlotFactor - currentSlotFactor;

                    if (factorJump >= RPS_FACTOR_JUMP && factorJump > maxFactorJump) {
                        
                        const newRpsOriginal = (targetSlotFactor * currentGMVFactor * 50); 
                        const newRpsTotal = newRpsOriginal * RPS_PROMO_MULTIPLIER; 
                        const newGrossFees = currentPayout * targetFeePercent; 

                        const newPromo = getSlotPromocode(duration, targetSlot);
                        let newNetFees = newGrossFees;
                        let newIsZeroPromo = false;
                        let newTotalSavings = 0;
                        
                        if (newPromo) {
                            if (targetFeePercent > 0) {
                                const calculatedDiscount = newGrossFees * newPromo.discount_percent;
                                const actualDiscount = Math.min(calculatedDiscount, newPromo.discount_cap);
                                newNetFees = newGrossFees - actualDiscount;
                                newTotalSavings = actualDiscount;
                            } else if (targetFeePercent === 0) {
                                 newNetFees = 0;
                                 newIsZeroPromo = true;
                                 const calculatedInstallmentDiscount = baseInstallment * newPromo.discount_percent; 
                                 const actualInstallmentDiscount = Math.min(calculatedInstallmentDiscount, newPromo.discount_cap);
                                 newTotalSavings = actualInstallmentDiscount; 
                            }
                        } else if (targetFeePercent < 0) {
                             const totalDiscount = Math.abs(newGrossFees);
                             newTotalSavings = totalDiscount;
                        }
                        
                        const recommendedSchedule = buildSchedule(baseInstallment, newNetFees, duration, targetSlot, currentPayout, newIsZeroPromo, 'Normal');
                        const originalScheduleForRec = buildSchedule(baseInstallment, newGrossFees, duration, targetSlot, currentPayout, false, 'Normal'); 

                        maxFactorJump = factorJump; 
                        bestSlotRecommendation = {
                            upgradeFound: true,
                            type: 'slot',
                            newRps: newRpsTotal,
                            newSchedule: recommendedSchedule,
                            newScheduleOriginal: originalScheduleForRec,
                            newSlot: targetSlot, 
                            newPayout: currentPayout,
                            newBaseInstallment: baseInstallment,
                            newGrossFees: newGrossFees,
                            newPromoCode: newPromo ? newPromo.code : 'N/A',
                            newTotalSavings: newTotalSavings,
                            newDuration: duration,
                            originalSlot: currentSlot, 
                            originalPayout: currentPayout, 
                            text: `EASY UPGRADE: Recommend moving the Slot from ${currentSlot} to ${targetSlot}. This increases the Position Factor by ${factorJump} (from ${currentSlotFactor} to ${targetSlotFactor}), achieving a new RPS Score of ${formatter.format(newRpsTotal)}.`,
                        };
                    }
                }
            }
            
            return bestSlotRecommendation;
        }
        // --- END NEW RPS RECOMMENDATION LOGIC ---

        function calculatePayout(event) {
            // ** FIX: Wrap core logic in try...catch to diagnose errors **
            try {
                if (event && event.preventDefault) {
                    event.preventDefault();
                }
                hideError();
                recommendedRpsWrapper.classList.add('hidden'); // Hide recommendation details initially

                // --- 1. Get and Validate Inputs ---
                const CircleType = circleTypeSelect.value;
                const Duration = parseInt(durationSelect.value);
                const SlotPosition = parseInt(slotSelect.value);
                
                let PayoutAmount;
                if (CircleType === 'Smart Saving') {
                    PayoutAmount = parseFloat(payoutAmountSelect.value);
                    if (!isValidSmartSavingPayoutAmount(PayoutAmount)) {
                         return showError("Please select a valid Payout Amount for Smart Saving.");
                    }
                } else {
                    PayoutAmount = parseFloat(payoutAmountInput.value);
                    // ** NEW VALIDATION: Check if PayoutAmount is in the GMV table **
                    if (!isValidNormalPayoutAmount(PayoutAmount)) {
                         // Check standard bounds first (optional, but good practice)
                        if (PayoutAmount < 3000 || PayoutAmount > 1200000) {
                            return showError("Please enter a valid Requested Payout Amount between 3,000 and 1,200,000 EGP.");
                        }
                        return showError("Invalid Requested Payout Amount. Please choose a multiple of 3,000 EGP.");
                    }
                }

                if (isNaN(Duration) || isNaN(SlotPosition) || isNaN(PayoutAmount)) {
                    resultsSection.classList.add('hidden');
                    return;
                }

                // --- 2. Base Calculation ---
                const baseInstallment = PayoutAmount / Duration;
                const baseFeePercent = getFeePercent(CircleType, Duration, SlotPosition);
                
                if (baseFeePercent === null) {
                    return showError(`Error: Fee data not found for ${CircleType} ${Duration}M Slot ${SlotPosition}. Please check the embedded data.`);
                }

                const grossFeesEGP = PayoutAmount * baseFeePercent; // For Smart Saving this is Cashback amount
                const isPositiveFee = baseFeePercent > 0;
                const isZeroFee = baseFeePercent === 0;
                const isNegativeFee = baseFeePercent < 0;

                // --- 3. Determine Original Installment Schedule (CURRENT selection, no promo) ---
                const originalSchedule = buildSchedule(baseInstallment, grossFeesEGP, Duration, SlotPosition, PayoutAmount, false, CircleType); // Pass CircleType
                
                // --- 4. Determine Promo Schedule (if applicable to CURRENT selection) ---
                let promoSchedule = null;
                let promoCode = null;
                let promoDetails = null;
                let totalSavings = 0; // Initialize total savings for current selection
                const RPS_PROMO_MULTIPLIER = 0.90; // 10% discount
                let rpsPromoTotal = 0;
                let netFeesEGP = grossFeesEGP; // Initialize net fees with gross for context

                const slotPromo = getSlotPromocode(Duration, SlotPosition);
                
                if (CircleType === 'Normal') {
                    const rpsTotal = (getPayoutFactor(PayoutAmount) * getSlotFactor(SlotPosition) * 50);
                    rpsPromoTotal = rpsTotal * RPS_PROMO_MULTIPLIER; // Calculate 90% of base RPS
                }

                if (slotPromo && CircleType === 'Normal') { // Promos only apply to Normal
                    promoCode = slotPromo.code;
                    promoDetails = `Discount: ${formatPercent(slotPromo.discount_percent)} / Cap: ${formatter.format(slotPromo.discount_cap)}`;
                    
                    if (isPositiveFee) {
                        // POSITIVE FEE LOGIC (Fees Discounted)
                        const calculatedDiscount = grossFeesEGP * slotPromo.discount_percent;
                        const actualDiscount = Math.min(calculatedDiscount, slotPromo.discount_cap);
                        netFeesEGP = grossFeesEGP - actualDiscount;
                        totalSavings = actualDiscount; // Savings is the discount applied to fees
                        
                        promoSchedule = buildSchedule(baseInstallment, netFeesEGP, Duration, SlotPosition, PayoutAmount, false, CircleType);

                    } else if (isZeroFee) {
                        // ZERO FEE LOGIC (Installment Discounted - Single Month Cap)
                        const calculatedInstallmentDiscount = baseInstallment * slotPromo.discount_percent;
                        const actualInstallmentDiscount = Math.min(calculatedInstallmentDiscount, slotPromo.discount_cap);
                        const discountedInstallment = baseInstallment - actualInstallmentDiscount; // This is only for month 1
                        
                        totalSavings = actualInstallmentDiscount; // Savings is the single month discount
                        // Pass the original baseInstallment, the promo flag will handle the logic
                        promoSchedule = buildSchedule(baseInstallment, 0, Duration, SlotPosition, PayoutAmount, true, CircleType); 
                        
                    }
                } else if (isNegativeFee && CircleType === 'Normal') {
                    // Negative Fee Slots (Discount already built into the grossFeesEGP)
                    totalSavings = Math.abs(grossFeesEGP); 
                } else if (CircleType === 'Smart Saving') {
                     // Smart Saving: Savings is the cashback amount
                     totalSavings = Math.abs(grossFeesEGP); // grossFees is cashback for Smart Saving
                     netFeesEGP = grossFeesEGP;
                }

                // --- 5. RPS Calculation Logic ---
                const payoutFactor = getPayoutFactor(PayoutAmount);
                const slotFactor = getSlotFactor(SlotPosition);
                const rpsTotal = payoutFactor * slotFactor * 50;

                // --- 6. RPS Recommendation ---
                const rpsRecommendation = getRpsRecommendation(PayoutAmount, Duration, SlotPosition, isPositiveFee, baseFeePercent, baseInstallment, grossFeesEGP, rpsTotal); // Pass rpsTotal

                // --- Store context for modal access ---
                latestCalculationContext = {
                    payout: PayoutAmount,
                    duration: Duration,
                    slot: SlotPosition,
                    baseInstallment: baseInstallment,
                    grossFees: grossFeesEGP,
                    netFees: netFeesEGP, // Store net fees (after promo if applied)
                    totalSavings: totalSavings,
                    originalSchedule: originalSchedule,
                    promoSchedule: promoSchedule,
                    isPositiveFee: isPositiveFee,
                    isZeroFee: isZeroFee,
                    isNegativeFee: isNegativeFee,
                    payoutFactor: payoutFactor,
                    slotFactor: slotFactor,
                    rpsTotal: rpsTotal,
                    rpsPromoTotal: rpsPromoTotal, // Store promo RPS total
                    rec: rpsRecommendation.upgradeFound ? rpsRecommendation : null,
                    circleType: CircleType, // Store Circle Type
                    promoCode: promoCode // Store the promo code
                };


                // --- 7. Render Results ---
                let feeType;
                if (CircleType === 'Smart Saving') {
                    feeType = 'Smart Saving';
                    promoScheduleWrapper.classList.add('hidden'); // No promo comparison for Smart Saving
                    originalScheduleWrapper.classList.remove('lg:w-1/2'); // Make original table full width
                } else {
                    originalScheduleWrapper.classList.add('lg:w-1/2'); // Ensure original table is half width if Normal
                    if (isPositiveFee) {
                        feeType = 'Positive Fee';
                        promoScheduleWrapper.classList.toggle('hidden', !promoSchedule);
                    } else if (isZeroFee) {
                        feeType = 'Zero Fee';
                        promoScheduleWrapper.classList.toggle('hidden', !promoSchedule);
                    } else {
                        feeType = 'Negative Fee';
                        promoScheduleWrapper.classList.add('hidden');
                    }
                }
                
                // Pass totalSavings and rpsPromoTotal to renderPayoutResults
                renderPayoutResults(baseInstallment, grossFeesEGP, promoCode, promoDetails, payoutFactor, slotFactor, rpsTotal, feeType, rpsRecommendation, totalSavings, rpsPromoTotal);
                renderInstallmentTable('installment-table-original-body', originalSchedule, SlotPosition);
                
                if (promoSchedule) {
                    renderInstallmentTable('installment-table-promo-body', promoSchedule, SlotPosition);
                }

                // Render Recommendation Details (Schedules and New RPS)
                if (rpsRecommendation.upgradeFound) {
                    // Check if schedule is defined for comparison (it should be)
                    if (rpsRecommendation.newScheduleOriginal && rpsRecommendation.newSchedule) {
                        
                        // Determine if recommended slot has negative fees
                        const recommendedSlotFeePercent = getFeePercent('Normal', Duration, rpsRecommendation.newSlot);
                        const recommendedSlotIsNegativeFee = recommendedSlotFeePercent < 0;

                        renderRecommendationDetails(
                            rpsRecommendation.newScheduleOriginal, 
                            rpsRecommendation.newSchedule, 
                            SlotPosition, // Original Slot Position
                            rpsRecommendation.newSlot, // Recommended Slot Position (used for payout highlight)
                            {
                                newBaseInstallment: rpsRecommendation.newBaseInstallment,
                                newGrossFees: rpsRecommendation.newGrossFees,
                                newPromoCode: rpsRecommendation.newPromoCode,
                                newTotalSavings: rpsRecommendation.newTotalSavings,
                                type: rpsRecommendation.type,
                                originalSlot: rpsRecommendation.originalSlot,
                                originalPayout: rpsRecommendation.originalPayout,
                                newSlot: rpsRecommendation.newSlot,
                                newPayout: rpsRecommendation.newPayout,
                            },
                            recommendedSlotIsNegativeFee // Pass the flag
                        );
                    } else {
                         // Fallback for missing schedule data in recommendation
                        recommendedRpsWrapper.classList.add('hidden');
                        document.getElementById('recommendation-text').textContent += ` (Note: Could not calculate comparison schedule for this recommendation.)`;
                    }
                } else {
                    recommendedRpsWrapper.classList.add('hidden');
                }

                resultsSection.classList.remove('hidden');

            } catch (e) {
                // ** Display the error to the user for diagnosis **
                console.error("Calculation execution failed:", e);
                showError(`A critical calculation error occurred. Details: ${e.message}. The data or logic may be inconsistent for this selection.`);
            }
        }

        /**
         * 8. SCHEDULE BUILDER
         */

        function buildSchedule(monthlyInstallment, totalFees, duration, slotPosition, PayoutAmount, isZeroFeePromo, circleType) { // Added circleType
            const schedule = [];
            const isPositiveOrZeroFee = totalFees >= 0;

            // --- SMART SAVING LOGIC ---
            if (circleType === 'Smart Saving') {
                const cashbackPercent = getFeePercent(circleType, duration, slotPosition); // Fee % is Cashback % here
                const cashbackAmount = PayoutAmount * cashbackPercent;
                const baseInstallment = PayoutAmount / duration;

                 for (let i = 1; i <= duration; i++) {
                    let installment = baseInstallment;
                    let netPayout = 0;

                    if (i === slotPosition) { // Payout month is always the last month (slot = duration)
                        installment = 0;
                        netPayout = PayoutAmount - baseInstallment + cashbackAmount; // Payout - Installment + Cashback
                    } else if (i > slotPosition) {
                         // Should not happen for Smart Saving as payout is last month
                         installment = 0; 
                    }
                     schedule.push({
                        month: i,
                        installment: installment,
                        netPayout: netPayout,
                    });
                 }
                 return schedule; // Exit early for Smart Saving
            }

            // --- NORMAL CIRCLE LOGIC ---

            // Positive/Zero Fee Schedule Logic
            if (isPositiveOrZeroFee) {
                
                // Total fees must be non-negative for this block
                const feesToDistribute = Math.max(0, totalFees); 
                const distributedFeePerMonth = slotPosition > 0 ? feesToDistribute / slotPosition : 0; // Avoid division by zero
                
                // Calculate the one-time discount amount for Zero Fee Promo
                let oneTimeDiscount = 0;
                if (isZeroFeePromo) {
                     const promo = getSlotPromocode(duration, slotPosition);
                     if (promo) {
                         const calculatedDiscount = monthlyInstallment * promo.discount_percent;
                         oneTimeDiscount = Math.min(calculatedDiscount, promo.discount_cap);
                     }
                }

                for (let i = 1; i <= duration; i++) {
                    let installment = monthlyInstallment;
                    let netPayout = 0;
                    
                    if (i < slotPosition) {
                        // Months before Payout: Add distributed fee (only if fees > 0)
                        if (feesToDistribute > 0 && !isZeroFeePromo) {
                           // Positive Fee: Fee is collected in installments
                           installment = monthlyInstallment + distributedFeePerMonth;
                        } else if (isZeroFeePromo) {
                           // Zero Fee Promo: Apply one-time discount to Month 1 only
                           if (i === 1) {
                                installment = monthlyInstallment - oneTimeDiscount;
                           } else {
                                installment = monthlyInstallment;
                           }
                        }
                    } else if (i === slotPosition) {
                        // Payout Month
                        installment = 0;
                        
                        // Final Payout calculation 
                        if (feesToDistribute > 0) {
                            // Fees remaining to be collected in the payout month is equal to distributedFeePerMonth
                            const feesRemainingToBeCollected = distributedFeePerMonth;
                            
                            // Net Payout = Payout Amount - base installment - fees remaining
                            netPayout = PayoutAmount - monthlyInstallment - feesRemainingToBeCollected; 
                            
                        } else {
                            // Zero Fees: Only deduct base installment
                            netPayout = PayoutAmount - monthlyInstallment;
                        }

                    }
                    
                    schedule.push({
                        month: i,
                        installment: installment,
                        netPayout: netPayout,
                    });
                }
            } else {
                // Negative Fee Schedule Logic (Discount)
                const totalDiscount = Math.abs(totalFees);
                const discountedInstallmentMonths = 4; // First 4 months

                // Distributed Discount Amount (DDA)
                const DDA = totalDiscount / discountedInstallmentMonths;

                for (let i = 1; i <= duration; i++) {
                    let installment = monthlyInstallment;
                    
                    if (i <= discountedInstallmentMonths) {
                        // Deduct discount from the first 4 installments
                        installment = monthlyInstallment - DDA;
                    }
                    
                    let netPayout = 0;
                    if (i === slotPosition) {
                        // Payout Month
                        installment = 0;
                        // Net Payout for negative fee (discount) slots: Original Payout - Base Installment
                        netPayout = PayoutAmount - monthlyInstallment;
                    } 

                    schedule.push({
                        month: i,
                        installment: installment,
                        netPayout: netPayout,
                    });
                }
            }
            return schedule;
        }


        /**
         * 6. EVENT LISTENERS & INITIALIZATION
         */
        
        // ** MODIFICATION 2: The init() function is now async to fetch data first **
        async function init() {
            try {
                // Fetch the external data file
                const response = await fetch('data.json'); // Assumes data.json is in the same folder
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                calculatorData = await response.json();

                // Now that data is loaded, attach listeners
                circleTypeSelect.addEventListener('change', handleCircleTypeChange);

                durationSelect.addEventListener('change', () => {
                    hideError();
                    updateSlotOptions();
                    calculatePayout(null);
                });

                slotSelect.addEventListener('change', () => {
                    calculatePayout(null);
                });

                payoutAmountInput.addEventListener('input', () => {
                    if (resultsSection.classList.contains('hidden')) return;
                    calculatePayout(null);
                });
                payoutAmountSelect.addEventListener('change', () => {
                     if (resultsSection.classList.contains('hidden')) return;
                     calculatePayout(null);
                });

                form.addEventListener('submit', calculatePayout);

                // Initial population and calculation trigger
                handleCircleTypeChange();

            } catch (e) {
                console.error('Failed to load initial data:', e);
                // Display a critical error to the user in the UI
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = `CRITICAL ERROR: Could not load calculator data from data.json. Please check the file. [${e.message}]`;
                errorDiv.classList.remove('hidden');
                // Hide the main form to prevent usage
                document.getElementById('calculator-form').classList.add('hidden');
            }
        }

        // Start initialization after the DOM is fully loaded
        window.onload = init; 
    </script>

</body>
</html>
